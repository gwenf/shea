#!/usr/bin/env node

/* 
  to connect as a lite client to a running chain, we need: 
  - genesis.json
  - initial node address

  for now, these can be passed as cli arguments.
  soon tho, the entire app should just be a single ipfs hash.
  the ipfs hash will be used to download the genesis.json
  and as the rendezvous for discovering seed nodes to run
  as a lite client of.

  might require chrome to be installed and open the client in incognito
  to prevent browser extensions from doing nasty things.

  `shea` will connect as a lite client to the specified node, then when 
  a state query comes back with a string value in `state.clientCode`, serves
  that code as javascript and opens chrome pointing at that url.

  `shea` also runs a `/sign` endpoint which will sign any data posted to it.
  `shea` manages persisting this keypair. each keypair is used only for one app.

  lotion apps can require('shea') and pass it the genesis.
  this will also announce the running node as a full-node for discovery by users.
  should this be implemented as lotion middleware? probably not. better pattern is probably
  require('shea')(app), and `app` can have methods for accessing genesis, tendermint node info, etc

*/

let { argv } = require('yargs')
let axios = require('axios')
let getPort = require('get-port')
let express = require('express')
let proxy = require('express-http-proxy')
let { json } = require('body-parser')
let opn = require('opn')

let GCI = argv._[0] || ''
let gatewayMode = argv.g || false

let lotion = require('lotion')
let clients = {}

function connectByGCI(gci) {
  return new Promise(async (resolve, reject) => {
    if (!clients[gci]) {
      clients[gci] = lotion.connect(gci)
    }
    resolve(await clients[gci])
  })
}

async function getClientCode(client) {
  let state = await client.getState()
  if(typeof state !== 'object' || !state._sheaClientCode){
    return 'no app found'
  } else {
    return state._sheaClientCode
  }
}

function parseGCIFromHeaders(headers) {
   let referer = headers.referer
    if(!referer) {
      return false
    }
    let gci = referer.split('/')[referer.split('/').length - 1]
    if(typeof gci !== 'string' || !gci.length) {
      return false
    }
    return gci
}

async function main() {
  let expressPort = process.env.PORT || await getPort(7777)
  let expressApp = express()

  expressApp.use(json())

  expressApp.get('/', async (req, res) => {
    res.send('You are now connected to a Shea gateway. Make sure this gateway is operated by you or someone you trust.')
  })

  expressApp.get('/state', async (req, res) => {
    let gci = parseGCIFromHeaders(req.headers) 
    if(!gci) {
      return res.sendStatus(400)
    }
    let client = await connectByGCI(gci)
    res.json(await client.getState())
  })
  expressApp.post('/txs', async (req, res) => {
    let gci = parseGCIFromHeaders(req.headers) 
    if(!gci) {
      return res.sendStatus(400)
    }
    let client = await connectByGCI(gci)
    res.json(await client.send(req.body))
  })
  expressApp.get('/:gci', async (req, res) => {
    let client = await connectByGCI(req.params.gci)
    let clientCode = await getClientCode(client)
    res.send(clientCode)
  })
  expressApp.get('/:gci/state', async (req, res) => {
    let client = await connectByGCI(req.params.gci)
    res.json(await client.getState())
  })
  expressApp.post('/:gci/txs', async (req, res) => {
    let client = await connectByGCI(req.params.gci)
    res.json(await client.send(req.body))
  })

  expressApp.listen(expressPort)
  if(!gatewayMode) {
    opn('http://localhost:' + expressPort + '/' + GCI)
  }
}

main()
